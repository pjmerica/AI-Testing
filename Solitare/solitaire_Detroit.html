<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Detroit Solitaire by PJ Merica</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: radial-gradient(ellipse at center, #1e8a4a 0%, #145a30 60%, #0d3d20 100%);
    font-family: 'Segoe UI', Arial, sans-serif;
    user-select: none;
    overflow: hidden;
    height: 100vh;
    height: 100dvh;
    touch-action: none;
  }

  /* --- Header Bar --- */
  #header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 24px;
    background: linear-gradient(180deg, #0d3d20 0%, #0a2e18 100%);
    color: #ddd;
    font-size: 14px;
    border-bottom: 1px solid #073012;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    min-height: 48px;
    z-index: 100;
    position: relative;
    flex-wrap: wrap;
    gap: 4px 16px;
  }
  #header h1 {
    font-size: 20px;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
    letter-spacing: 0.5px;
  }

  .stat-group {
    display: flex;
    gap: 24px;
    align-items: center;
  }
  .stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.2;
  }
  .stat-label { font-size: 10px; text-transform: uppercase; color: #8cb89e; letter-spacing: 1px; }
  .stat-value { font-size: 18px; font-weight: 700; color: #fff; font-variant-numeric: tabular-nums; }

  .btn-group { display: flex; gap: 8px; flex-wrap: wrap; }
  .btn {
    background: rgba(255,255,255,0.1);
    color: #fff;
    border: 1px solid rgba(255,255,255,0.15);
    padding: 6px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.15s;
  }
  .btn:hover { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.3); }
  .btn:active { transform: scale(0.96); }
  .btn.primary { background: rgba(255,215,0,0.2); border-color: rgba(255,215,0,0.35); color: #ffd700; }
  .btn.primary:hover { background: rgba(255,215,0,0.3); }

  .draw-toggle {
    font-size: 12px;
    padding: 4px 10px;
    border-radius: 12px;
    cursor: pointer;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    color: #aaa;
    transition: all 0.15s;
  }
  .draw-toggle.active { background: rgba(255,215,0,0.15); border-color: rgba(255,215,0,0.3); color: #ffd700; }

  /* --- Game Area --- */
  #game-wrapper {
    width: 100%;
    height: calc(100vh - 48px);
    overflow: hidden;
    position: relative;
  }
  #game {
    position: relative;
    transform-origin: top left;
  }

  /* --- Mobile --- */
  @media (max-width: 600px) {
    #header { padding: 6px 12px; gap: 4px 8px; justify-content: center; }
    #header h1 { font-size: 16px; width: 100%; text-align: center; }
    .stat-group { gap: 16px; }
    .stat-label { font-size: 9px; }
    .stat-value { font-size: 15px; }
    .btn { padding: 5px 10px; font-size: 12px; }
    .draw-toggle { font-size: 11px; padding: 3px 8px; }
  }

  /* --- Cards --- */
  .card {
    position: absolute;
    width: 86px;
    height: 120px;
    border-radius: 8px;
    background: #fff;
    cursor: grab;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 5px 7px;
    font-size: 15px;
    font-weight: 700;
    box-shadow: 0 1px 3px rgba(0,0,0,0.25);
    transition: box-shadow 0.15s, transform 0.15s;
  }
  .card:hover { box-shadow: 0 3px 12px rgba(0,0,0,0.35); transform: translateY(-1px); }
  .card.red { color: #d32f2f; }
  .card.black { color: #222; }

  .card .corner { line-height: 1; }
  .card .corner-br { text-align: right; transform: rotate(180deg); }
  .card .center-suit {
    text-align: center;
    font-size: 36px;
    flex-grow: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0.85;
  }

  .card.facedown {
    cursor: default;
    padding: 0;
    overflow: hidden;
  }
  .card.facedown .card-back {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;
  }
  .card.facedown .card-back .team-name {
    font-size: 9px;
    font-weight: 800;
    letter-spacing: 1.5px;
    text-transform: uppercase;
  }
  .card.facedown .card-back .team-logo {
    line-height: 0;
    filter: drop-shadow(0 1px 3px rgba(0,0,0,0.3));
  }
  .card.facedown .card-back .team-city {
    font-size: 7px;
    font-weight: 600;
    letter-spacing: 2px;
    text-transform: uppercase;
    opacity: 0.7;
  }
  .card.facedown .card-back::before {
    content: '';
    position: absolute;
    top: 5px; left: 5px; right: 5px; bottom: 5px;
    border-radius: 4px;
    pointer-events: none;
  }

  /* Detroit Lions - Spades */
  .card.facedown.back-lions .card-back {
    background: linear-gradient(160deg, #0076B6 0%, #005a8e 50%, #0076B6 100%);
    border: 2.5px solid #004d7a;
    color: #B0B7BC;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3), inset 0 0 0 3px rgba(176,183,188,0.1);
  }
  .card.facedown.back-lions .card-back::before {
    border: 1.5px solid rgba(176,183,188,0.2);
  }
  .card.facedown.back-lions .card-back .team-logo { color: #fff; }
  .card.facedown.back-lions .card-back .team-name { color: #B0B7BC; }

  /* Detroit Red Wings - Hearts */
  .card.facedown.back-redwings .card-back {
    background: linear-gradient(160deg, #CE1141 0%, #a80d34 50%, #CE1141 100%);
    border: 2.5px solid #8a0a2a;
    color: #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3), inset 0 0 0 3px rgba(255,255,255,0.08);
  }
  .card.facedown.back-redwings .card-back::before {
    border: 1.5px solid rgba(255,255,255,0.2);
  }
  .card.facedown.back-redwings .card-back .team-logo { color: #fff; }

  /* Detroit Tigers - Diamonds */
  .card.facedown.back-tigers .card-back {
    background: linear-gradient(160deg, #0C2340 0%, #081a2e 50%, #0C2340 100%);
    border: 2.5px solid #060f1a;
    color: #FA4616;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3), inset 0 0 0 3px rgba(250,70,22,0.08);
  }
  .card.facedown.back-tigers .card-back::before {
    border: 1.5px solid rgba(250,70,22,0.25);
  }
  .card.facedown.back-tigers .card-back .team-name { color: #fff; }

  /* Detroit Pistons - Clubs */
  .card.facedown.back-pistons .card-back {
    background: linear-gradient(160deg, #1D42BA 0%, #15338f 50%, #1D42BA 100%);
    border: 2.5px solid #0f2870;
    color: #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3), inset 0 0 0 3px rgba(200,16,46,0.1);
  }
  .card.facedown.back-pistons .card-back::before {
    border: 1.5px solid rgba(200,16,46,0.3);
  }
  .card.facedown.back-pistons .card-back .team-logo { color: #C8102E; }

  .card.facedown:hover { transform: none; }

  .card.dragging {
    box-shadow: 0 12px 32px rgba(0,0,0,0.5);
    z-index: 10000 !important;
    pointer-events: none;
    cursor: grabbing;
    transform: rotate(2deg);
  }

  .card.animate-move {
    transition: left 0.2s ease-out, top 0.2s ease-out;
  }

  .card.highlight-valid {
    box-shadow: 0 0 0 3px #ffd700, 0 0 16px rgba(255,215,0,0.4);
  }

  /* --- Placeholders --- */
  .placeholder {
    position: absolute;
    width: 86px;
    height: 120px;
    border-radius: 8px;
    border: 2px dashed rgba(255,255,255,0.2);
    background: rgba(0,0,0,0.06);
  }
  .placeholder.foundation::after {
    content: attr(data-suit);
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 32px;
    opacity: 0.2;
  }
  .placeholder.stock-empty {
    cursor: pointer;
    border-style: solid;
    border-color: rgba(255,255,255,0.15);
  }
  .placeholder.stock-empty::after {
    content: '‚Üª';
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 32px;
    color: rgba(255,255,255,0.35);
  }
  .placeholder.stock-empty:hover { background: rgba(255,255,255,0.06); }
  .placeholder.drop-target {
    border-color: rgba(255,215,0,0.6);
    background: rgba(255,215,0,0.08);
    box-shadow: 0 0 12px rgba(255,215,0,0.15);
  }

  /* --- Win Overlay --- */
  #win-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.8);
    z-index: 20000;
    align-items: center;
    justify-content: center;
    flex-direction: column;
  }
  #win-overlay.show { display: flex; }
  #win-overlay h2 {
    color: #ffd700;
    font-size: 52px;
    margin-bottom: 8px;
    text-shadow: 0 2px 20px rgba(255,215,0,0.4);
  }
  #win-overlay p { color: #ccc; font-size: 18px; margin-bottom: 8px; }
  #win-overlay .win-score { color: #fff; font-size: 28px; font-weight: 700; margin-bottom: 24px; }
  #win-overlay button {
    background: linear-gradient(135deg, #ffd700, #f0c000);
    color: #333;
    border: none;
    padding: 14px 40px;
    border-radius: 8px;
    font-size: 18px;
    cursor: pointer;
    font-weight: 700;
    box-shadow: 0 4px 16px rgba(255,215,0,0.3);
    transition: transform 0.15s;
  }
  #win-overlay button:hover { transform: scale(1.05); }

  /* --- Cascade canvas --- */
  #cascade-canvas {
    position: fixed;
    top: 0; left: 0;
    pointer-events: none;
    z-index: 19999;
  }
</style>
</head>
<body>

<div id="header">
  <h1>Detroit Solitaire by PJ Merica</h1>
  <div class="stat-group">
    <div class="stat"><span class="stat-label">Score</span><span class="stat-value" id="score-display">0</span></div>
    <div class="stat"><span class="stat-label">Moves</span><span class="stat-value" id="move-display">0</span></div>
    <div class="stat"><span class="stat-label">Time</span><span class="stat-value" id="timer-display">0:00</span></div>
  </div>
  <div class="btn-group">
    <span class="draw-toggle active" id="draw1-btn" onclick="setDrawMode(1)">Draw 1</span>
    <span class="draw-toggle" id="draw3-btn" onclick="setDrawMode(3)">Draw 3</span>
    <button class="btn" onclick="undoMove()">Undo</button>
    <button class="btn" onclick="autoComplete()">Auto Complete</button>
    <button class="btn primary" onclick="newGame()">New Game</button>
  </div>
</div>

<div id="game-wrapper"><div id="game"></div></div>
<canvas id="cascade-canvas"></canvas>

<div id="win-overlay">
  <h2>You Win!</h2>
  <p id="win-stats"></p>
  <div class="win-score" id="win-score"></div>
  <button onclick="newGame()">Play Again</button>
</div>

<script>
// ========== Constants ==========
const SUITS = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
const SUIT_COLOR = {'‚ô†':'black','‚ô£':'black','‚ô•':'red','‚ô¶':'red'};
const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const CARD_W = 86, CARD_H = 120;
const OVERLAP_DOWN = 20, OVERLAP_UP = 28;
const FOUND_SUITS = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
const PAD = 24;
const COL_GAP = 14;
const NATIVE_WIDTH = 7 * (CARD_W + COL_GAP) - COL_GAP + PAD * 2; // ~724px

// ========== Responsive Scaling ==========
let scaleFactor = 1;

function updateScale() {
  let wrapper = document.getElementById('game-wrapper');
  let game = document.getElementById('game');
  let availW = wrapper.clientWidth;
  let availH = wrapper.clientHeight;
  scaleFactor = Math.min(1, availW / NATIVE_WIDTH);
  game.style.transform = 'scale(' + scaleFactor + ')';
  game.style.width = (availW / scaleFactor) + 'px';
  game.style.height = (availH / scaleFactor) + 'px';
}

// Convert screen coords to game coords
function toGameCoords(screenX, screenY) {
  let wrapper = document.getElementById('game-wrapper');
  let rect = wrapper.getBoundingClientRect();
  return {
    x: (screenX - rect.left) / scaleFactor,
    y: (screenY - rect.top) / scaleFactor
  };
}

window.addEventListener('resize', () => { updateScale(); });
window.addEventListener('orientationchange', () => { setTimeout(updateScale, 200); });

// ========== State ==========
let stock, waste, foundations, tableau;
let cardElements = {};
let moves, score, timerSeconds, timerInterval;
let historyStack = [];
let drawMode = 1;
let gameStarted = false;

// ========== Card ==========
function makeCard(rank, suit) { return { rank, suit, faceUp: false, id: rank + suit }; }
function rankVal(r) { return RANKS.indexOf(r); }

function makeDeck() {
  let d = [];
  for (let s of SUITS) for (let r of RANKS) d.push(makeCard(r, s));
  return d;
}

function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// ========== Layout ==========
function stockX() { return PAD; }
function stockY() { return PAD; }
function wasteX() { return PAD + CARD_W + COL_GAP; }
function wasteY() { return PAD; }
function foundX(i) { return PAD + (3 + i) * (CARD_W + COL_GAP); }
function foundY() { return PAD; }
function tabX(col) { return PAD + col * (CARD_W + COL_GAP); }
function tabY() { return PAD + CARD_H + 30; }

// ========== Draw Mode ==========
function setDrawMode(n) {
  drawMode = n;
  document.getElementById('draw1-btn').classList.toggle('active', n === 1);
  document.getElementById('draw3-btn').classList.toggle('active', n === 3);
}

// ========== Game ==========
function newGame() {
  document.getElementById('win-overlay').classList.remove('show');
  stopCascade();
  clearInterval(timerInterval);
  timerSeconds = 0; moves = 0; score = 0;
  historyStack = [];
  gameStarted = false;
  updateStats();

  let deck = shuffle(makeDeck());
  stock = []; waste = [];
  foundations = [[], [], [], []];
  tableau = [[], [], [], [], [], [], []];

  for (let c = 0; c < 7; c++)
    for (let r = 0; r <= c; r++) {
      let card = deck.pop();
      card.faceUp = (r === c);
      tableau[c].push(card);
    }
  stock = deck.reverse();
  render();
  updateScale();
}

function startTimer() {
  if (gameStarted) return;
  gameStarted = true;
  timerInterval = setInterval(() => { timerSeconds++; updateTimer(); }, 1000);
}

function saveState() {
  historyStack.push(JSON.stringify({ stock, waste, foundations, tableau, moves, score }));
  if (historyStack.length > 200) historyStack.shift();
}

function undoMove() {
  if (historyStack.length === 0) return;
  let st = JSON.parse(historyStack.pop());
  stock = st.stock; waste = st.waste;
  foundations = st.foundations; tableau = st.tableau;
  moves = st.moves; score = st.score;
  updateStats();
  render();
}

function addScore(pts) { score = Math.max(0, score + pts); }

function updateStats() {
  document.getElementById('score-display').textContent = score;
  document.getElementById('move-display').textContent = moves;
  updateTimer();
}

function updateTimer() {
  let m = Math.floor(timerSeconds / 60);
  let s = (timerSeconds % 60).toString().padStart(2, '0');
  document.getElementById('timer-display').textContent = m + ':' + s;
}

// ========== Rendering ==========
function render() {
  let game = document.getElementById('game');
  game.innerHTML = '';
  cardElements = {};

  // Stock placeholder
  let sph = createPlaceholder(stockX(), stockY());
  if (stock.length === 0) {
    sph.classList.add('stock-empty');
    sph.addEventListener('click', onStockClick);
  }
  game.appendChild(sph);

  // Waste placeholder
  game.appendChild(createPlaceholder(wasteX(), wasteY()));

  // Foundation placeholders
  for (let i = 0; i < 4; i++) {
    let fp = createPlaceholder(foundX(i), foundY());
    fp.classList.add('foundation');
    fp.dataset.suit = FOUND_SUITS[i];
    fp.dataset.foundIdx = i;
    game.appendChild(fp);
  }

  // Tableau placeholders
  for (let c = 0; c < 7; c++) {
    let tp = createPlaceholder(tabX(c), tabY());
    tp.dataset.tabCol = c;
    game.appendChild(tp);
  }

  // Stock cards
  stock.forEach((card, i) => {
    let el = renderCard(card, stockX(), stockY(), 100 + i);
    el.addEventListener('click', onStockClick);
    game.appendChild(el);
  });

  // Waste cards
  let showCount = drawMode === 3 ? 3 : 1;
  let wStart = Math.max(0, waste.length - showCount);
  for (let i = wStart; i < waste.length; i++) {
    let offset = (i - wStart) * 24;
    let el = renderCard(waste[i], wasteX() + offset, wasteY(), 200 + i);
    if (i === waste.length - 1) makeDraggable(el, waste[i], 'waste', i);
    game.appendChild(el);
  }

  // Foundation cards
  for (let f = 0; f < 4; f++) {
    foundations[f].forEach((card, i) => {
      let el = renderCard(card, foundX(f), foundY(), 300 + f * 20 + i);
      if (i === foundations[f].length - 1) makeDraggable(el, card, 'foundation', f);
      game.appendChild(el);
    });
  }

  // Tableau
  for (let col = 0; col < 7; col++) {
    let y = tabY();
    tableau[col].forEach((card, row) => {
      let el = renderCard(card, tabX(col), y, 500 + col * 30 + row);
      if (card.faceUp) makeDraggable(el, card, 'tableau', col, row);
      y += card.faceUp ? OVERLAP_UP : OVERLAP_DOWN;
    });
  }
}

function createPlaceholder(x, y) {
  let d = document.createElement('div');
  d.className = 'placeholder';
  d.style.left = x + 'px'; d.style.top = y + 'px';
  return d;
}

// Detroit team SVG logos
const TEAM_LOGOS = {
  lions: '<svg viewBox="0 0 60 50" width="52" height="44" fill="none" xmlns="http://www.w3.org/2000/svg">' +
    '<g fill="#fff">' +
    '<path d="M30 4C22 4 16 8 14 14C12 8 8 6 4 8C6 12 5 18 8 22C4 24 2 30 4 34C8 32 12 34 14 38C12 42 14 46 18 48C20 44 24 44 28 46L30 48L32 46C36 44 40 44 42 48C46 46 48 42 46 38C48 34 52 32 56 34C58 30 56 24 52 22C55 18 54 12 56 8C52 6 48 8 46 14C44 8 38 4 30 4Z" opacity="0.2"/>' +
    '<path d="M30 10C22 10 16 16 16 24C16 30 20 35 26 37L24 44L28 41L30 44L32 41L36 44L34 37C40 35 44 30 44 24C44 16 38 10 30 10Z"/>' +
    '<circle cx="24" cy="22" r="2.5" fill="#0076B6"/><circle cx="36" cy="22" r="2.5" fill="#0076B6"/>' +
    '<circle cx="24.5" cy="21.5" r="1" fill="#000"/><circle cx="36.5" cy="21.5" r="1" fill="#000"/>' +
    '<path d="M28 28L30 30L32 28Z" fill="#B0B7BC"/>' +
    '</g></svg>',

  redwings: '<svg viewBox="0 0 64 48" width="56" height="42" fill="none" xmlns="http://www.w3.org/2000/svg">' +
    '<g fill="#fff">' +
    // Wheel
    '<circle cx="22" cy="24" r="12" stroke="#fff" stroke-width="2.5" fill="none"/>' +
    '<circle cx="22" cy="24" r="4" fill="#fff"/>' +
    // Spokes
    '<line x1="22" y1="12" x2="22" y2="36" stroke="#fff" stroke-width="1.5"/>' +
    '<line x1="10" y1="24" x2="34" y2="24" stroke="#fff" stroke-width="1.5"/>' +
    '<line x1="13.5" y1="15.5" x2="30.5" y2="32.5" stroke="#fff" stroke-width="1.5"/>' +
    '<line x1="30.5" y1="15.5" x2="13.5" y2="32.5" stroke="#fff" stroke-width="1.5"/>' +
    // Wing
    '<path d="M34 22C38 18 44 14 52 12C56 11 60 12 60 14C58 16 54 18 50 20C54 20 58 21 60 22C58 24 54 24 48 24C44 24 40 23 34 22Z" fill="#fff"/>' +
    '<path d="M34 20C38 16 42 13 48 11" stroke="#CE1141" stroke-width="0.8" fill="none"/>' +
    '<path d="M34 21C40 17 46 14 54 13" stroke="#CE1141" stroke-width="0.8" fill="none"/>' +
    '</g></svg>',

  tigers: '<svg viewBox="0 0 44 52" width="40" height="48" fill="none" xmlns="http://www.w3.org/2000/svg">' +
    // Old English "D"
    '<path d="M10 6L10 46L22 46C34 46 40 38 40 26C40 14 34 6 22 6L10 6Z ' +
    'M18 13L22 13C29 13 33 18 33 26C33 34 29 39 22 39L18 39L18 13Z" ' +
    'fill="#FA4616" stroke="#FA4616" stroke-width="0.5"/>' +
    // Serifs on the D
    '<path d="M8 6L16 6L16 9L8 9Z" fill="#FA4616"/>' +
    '<path d="M8 43L16 43L16 46L8 46Z" fill="#FA4616"/>' +
    '</svg>',

  pistons: '<svg viewBox="0 0 50 50" width="44" height="44" fill="none" xmlns="http://www.w3.org/2000/svg">' +
    // Basketball
    '<circle cx="25" cy="25" r="20" stroke="#C8102E" stroke-width="2.5" fill="none"/>' +
    // Seam lines
    '<path d="M25 5C25 5 25 45 25 45" stroke="#C8102E" stroke-width="1.5"/>' +
    '<path d="M5 25C5 25 45 25 45 25" stroke="#C8102E" stroke-width="1.5"/>' +
    '<path d="M9 10C16 16 20 20 20 25C20 30 16 34 9 40" stroke="#C8102E" stroke-width="1.5" fill="none"/>' +
    '<path d="M41 10C34 16 30 20 30 25C30 30 34 34 41 40" stroke="#C8102E" stroke-width="1.5" fill="none"/>' +
    '</svg>'
};

const TEAM_BACKS = {
  '‚ô†': { cls: 'back-lions',    logo: '<span style="font-size:26px;line-height:1">ü¶Å</span>', name: 'LIONS', city: 'DETROIT' },
  '‚ô•': { cls: 'back-redwings', logo: TEAM_LOGOS.redwings, name: 'RED WINGS', city: 'DETROIT' },
  '‚ô¶': { cls: 'back-tigers',   logo: TEAM_LOGOS.tigers,   name: 'TIGERS',    city: 'DETROIT' },
  '‚ô£': { cls: 'back-pistons',  logo: TEAM_LOGOS.pistons,  name: 'PISTONS',   city: 'DETROIT' },
};

function renderCard(card, x, y, z) {
  let d = document.createElement('div');
  d.className = 'card';
  if (!card.faceUp) {
    d.classList.add('facedown');
    let team = TEAM_BACKS[card.suit];
    d.classList.add(team.cls);
    d.innerHTML =
      '<div class="card-back">' +
        '<span class="team-city">' + team.city + '</span>' +
        '<span class="team-logo">' + team.logo + '</span>' +
        '<span class="team-name">' + team.name + '</span>' +
      '</div>';
  } else {
    d.classList.add(SUIT_COLOR[card.suit]);
    let lbl = card.rank + '<span style="font-size:0.8em">' + card.suit + '</span>';
    d.innerHTML =
      '<div class="corner">' + lbl + '</div>' +
      '<div class="center-suit">' + card.suit + '</div>' +
      '<div class="corner corner-br">' + lbl + '</div>';
  }
  d.style.left = x + 'px'; d.style.top = y + 'px'; d.style.zIndex = z;
  d.dataset.cardId = card.id;
  cardElements[card.id] = d;
  document.getElementById('game').appendChild(d);
  return d;
}

// ========== Stock ==========
function onStockClick() {
  startTimer();
  saveState();
  if (stock.length === 0) {
    if (waste.length === 0) return;
    stock = waste.reverse();
    stock.forEach(c => c.faceUp = false);
    waste = [];
    addScore(-20);
  } else {
    let count = Math.min(drawMode, stock.length);
    for (let i = 0; i < count; i++) {
      let card = stock.pop();
      card.faceUp = true;
      waste.push(card);
    }
  }
  moves++;
  updateStats();
  render();
}

// ========== Drag & Drop ==========
function makeDraggable(el, card, source, idx, row) {
  el.addEventListener('mousedown', startDrag);
  el.addEventListener('touchstart', startDrag, { passive: false });

  function startDrag(e) {
    e.preventDefault();
    startTimer();
    let isTouch = e.type === 'touchstart';
    let clientX = isTouch ? e.touches[0].clientX : e.clientX;
    let clientY = isTouch ? e.touches[0].clientY : e.clientY;

    let cards = [];
    if (source === 'tableau') {
      for (let r = row; r < tableau[idx].length; r++) cards.push(tableau[idx][r]);
    } else {
      cards = [card];
    }

    let startX = clientX, startY = clientY;
    let positions = [];
    let elements = [];

    cards.forEach(c => {
      let cEl = cardElements[c.id];
      positions.push({ left: parseInt(cEl.style.left), top: parseInt(cEl.style.top), z: cEl.style.zIndex });
      cEl.classList.add('dragging');
      cEl.style.zIndex = 10000 + positions.length;
      elements.push(cEl);
    });

    // Highlight valid drop targets
    highlightDropTargets(cards[0], cards.length === 1);

    function onMove(e) {
      let cx = isTouch ? e.touches[0].clientX : e.clientX;
      let cy = isTouch ? e.touches[0].clientY : e.clientY;
      // Divide by scaleFactor since card positions are in unscaled game space
      let dx = (cx - startX) / scaleFactor;
      let dy = (cy - startY) / scaleFactor;
      elements.forEach((el, i) => {
        el.style.left = (positions[i].left + dx) + 'px';
        el.style.top = (positions[i].top + dy) + 'px';
      });
    }

    function onEnd(e) {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onEnd);
      document.removeEventListener('touchmove', onMove);
      document.removeEventListener('touchend', onEnd);
      elements.forEach(el => el.classList.remove('dragging'));
      clearHighlights();

      let cx = isTouch ? e.changedTouches[0].clientX : e.clientX;
      let cy = isTouch ? e.changedTouches[0].clientY : e.clientY;
      // Convert screen coords to game coords for drop detection
      let gc = toGameCoords(cx, cy);

      let target = findDropTarget(gc.x, gc.y, cards);
      if (target) {
        saveState();
        let pts = executeMove(cards, source, idx, row, target);
        moves++;
        addScore(pts);
        updateStats();
        render();
        checkWin();
      } else {
        // Snap back with animation
        elements.forEach((el, i) => {
          el.classList.add('animate-move');
          el.style.left = positions[i].left + 'px';
          el.style.top = positions[i].top + 'px';
          el.style.zIndex = positions[i].z;
          setTimeout(() => el.classList.remove('animate-move'), 200);
        });
      }
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onEnd);
    document.addEventListener('touchmove', onMove, { passive: false });
    document.addEventListener('touchend', onEnd);
  }

  // Double-click or double-tap to auto-move to foundation
  el.addEventListener('dblclick', autoMoveCard);

  function autoMoveCard() {
    startTimer();
    if (source === 'tableau' && row !== tableau[idx].length - 1) return;
    let fi = findFoundationTarget(card);
    if (fi !== -1) {
      saveState();
      removeCardFrom(source, idx, row);
      foundations[fi].push(card);
      moves++;
      addScore(10);
      updateStats();
      render();
      checkWin();
    }
  }
}

function highlightDropTargets(card, isSingle) {
  // Highlight foundation placeholders
  if (isSingle) {
    for (let f = 0; f < 4; f++) {
      if (canPlaceOnFoundation(card, f)) {
        let topCard = foundations[f].length > 0 ? cardElements[foundations[f][foundations[f].length-1].id] : null;
        if (topCard) topCard.classList.add('highlight-valid');
        else document.querySelectorAll('.placeholder.foundation')[f].classList.add('drop-target');
      }
    }
  }
  // Highlight tableau
  for (let c = 0; c < 7; c++) {
    if (canPlaceOnTableau(card, c)) {
      let pile = tableau[c];
      if (pile.length > 0) {
        let topEl = cardElements[pile[pile.length-1].id];
        if (topEl) topEl.classList.add('highlight-valid');
      } else {
        document.querySelectorAll('.placeholder')[c + 6]?.classList.add('drop-target');
      }
    }
  }
}

function clearHighlights() {
  document.querySelectorAll('.highlight-valid').forEach(el => el.classList.remove('highlight-valid'));
  document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
}

function findDropTarget(mx, my, cards) {
  let card = cards[0];

  // Check foundations
  if (cards.length === 1) {
    for (let f = 0; f < 4; f++) {
      let fx = foundX(f), fy = foundY();
      if (mx >= fx - 10 && mx <= fx + CARD_W + 10 && my >= fy - 10 && my <= fy + CARD_H + 10) {
        if (canPlaceOnFoundation(card, f)) return { type: 'foundation', idx: f };
      }
    }
  }

  // Check tableau ‚Äî generous hit area
  for (let col = 0; col < 7; col++) {
    let tx = tabX(col);
    if (mx < tx - 10 || mx > tx + CARD_W + 10) continue;
    let pile = tableau[col];
    if (pile.length > 0) {
      let lastY = tabY();
      for (let r = 0; r < pile.length; r++) lastY += pile[r].faceUp ? OVERLAP_UP : OVERLAP_DOWN;
      if (my >= tabY() - 10 && my <= lastY + CARD_H + 10) {
        if (canPlaceOnTableau(card, col)) return { type: 'tableau', idx: col };
      }
    } else {
      if (my >= tabY() - 10 && my <= tabY() + CARD_H + 10) {
        if (canPlaceOnTableau(card, col)) return { type: 'tableau', idx: col };
      }
    }
  }
  return null;
}

function canPlaceOnFoundation(card, fIdx) {
  let pile = foundations[fIdx];
  if (pile.length === 0) return card.rank === 'A' && card.suit === FOUND_SUITS[fIdx];
  let top = pile[pile.length - 1];
  return card.suit === top.suit && rankVal(card.rank) === rankVal(top.rank) + 1;
}

function canPlaceOnTableau(card, col) {
  let pile = tableau[col];
  if (pile.length === 0) return card.rank === 'K';
  let top = pile[pile.length - 1];
  return top.faceUp && SUIT_COLOR[card.suit] !== SUIT_COLOR[top.suit] && rankVal(card.rank) === rankVal(top.rank) - 1;
}

function findFoundationTarget(card) {
  for (let f = 0; f < 4; f++) if (canPlaceOnFoundation(card, f)) return f;
  return -1;
}

function removeCardFrom(source, idx, row) {
  if (source === 'waste') {
    waste.splice(waste.indexOf(waste.find(c => c === waste[idx])), 1);
    // More reliable: remove last element of waste (always the dragged one)
  } else if (source === 'foundation') {
    foundations[idx].pop();
  } else if (source === 'tableau') {
    tableau[idx].splice(row);
    flipTop(idx);
  }
}

function executeMove(cards, source, srcIdx, srcRow, target) {
  let pts = 0;

  // Remove from source
  if (source === 'waste') {
    let ci = waste.indexOf(cards[0]);
    if (ci !== -1) waste.splice(ci, 1);
    if (target.type === 'tableau') pts = 5;
    if (target.type === 'foundation') pts = 10;
  } else if (source === 'foundation') {
    foundations[srcIdx].pop();
    pts = -15;
  } else if (source === 'tableau') {
    tableau[srcIdx].splice(srcRow);
    let flipped = flipTop(srcIdx);
    if (flipped) pts += 5;
    if (target.type === 'foundation') pts += 10;
  }

  // Add to target
  if (target.type === 'foundation') {
    foundations[target.idx].push(cards[0]);
  } else if (target.type === 'tableau') {
    cards.forEach(c => tableau[target.idx].push(c));
  }

  return pts;
}

function flipTop(col) {
  let pile = tableau[col];
  if (pile.length > 0 && !pile[pile.length - 1].faceUp) {
    pile[pile.length - 1].faceUp = true;
    return true;
  }
  return false;
}

// ========== Auto-Complete ==========
function autoComplete() {
  // Only allow if stock and waste are empty (or waste top can go) and all tableau cards are face-up
  let allFaceUp = tableau.every(col => col.every(c => c.faceUp));
  if (!allFaceUp && (stock.length > 0 || waste.length > 0)) return;

  function step() {
    let moved = false;

    // Try waste first
    if (waste.length > 0) {
      let card = waste[waste.length - 1];
      let fi = findFoundationTarget(card);
      if (fi !== -1) {
        saveState();
        waste.pop();
        foundations[fi].push(card);
        moves++; addScore(10); moved = true;
      }
    }

    // Try tableau
    for (let c = 0; c < 7; c++) {
      if (tableau[c].length === 0) continue;
      let card = tableau[c][tableau[c].length - 1];
      let fi = findFoundationTarget(card);
      if (fi !== -1) {
        saveState();
        tableau[c].pop();
        flipTop(c);
        foundations[fi].push(card);
        moves++; addScore(10); moved = true;
        break;
      }
    }

    updateStats();
    render();

    if (moved) {
      let total = foundations.reduce((s, f) => s + f.length, 0);
      if (total < 52) setTimeout(step, 120);
      else checkWin();
    }
  }

  step();
}

// ========== Win ==========
function checkWin() {
  let total = foundations.reduce((s, f) => s + f.length, 0);
  if (total === 52) {
    clearInterval(timerInterval);
    let m = Math.floor(timerSeconds / 60);
    let s = (timerSeconds % 60).toString().padStart(2, '0');
    // Time bonus
    let timeBonus = timerSeconds < 30 ? 0 : Math.max(0, Math.floor(700000 / timerSeconds));
    let finalScore = score + timeBonus;
    document.getElementById('win-stats').textContent = moves + ' moves  ¬∑  ' + m + ':' + s;
    document.getElementById('win-score').textContent = 'Score: ' + finalScore + (timeBonus > 0 ? ' (incl. ' + timeBonus + ' time bonus)' : '');
    startCascade();
    setTimeout(() => {
      document.getElementById('win-overlay').classList.add('show');
    }, 2500);
  }
}

// ========== Victory Cascade Animation ==========
let cascadeAnimId = null;
function startCascade() {
  let canvas = document.getElementById('cascade-canvas');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  let ctx = canvas.getContext('2d');

  let particles = [];
  // Launch cards from foundation positions
  for (let f = 0; f < 4; f++) {
    let suit = FOUND_SUITS[f];
    let col = SUIT_COLOR[suit];
    for (let r = 12; r >= 0; r--) {
      particles.push({
        x: foundX(f) + CARD_W / 2,
        y: foundY() + CARD_H / 2 + 48,
        vx: (Math.random() - 0.5) * 8,
        vy: -Math.random() * 6 - 2,
        rank: RANKS[r],
        suit: suit,
        color: col,
        delay: (12 - r) * 80 + f * 20,
        born: performance.now(),
        rotation: 0,
        vr: (Math.random() - 0.5) * 0.1
      });
    }
  }

  function draw(now) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let p of particles) {
      let age = now - p.born - p.delay;
      if (age < 0) continue;
      let t = age / 16;
      let x = p.x + p.vx * t;
      let y = p.y + p.vy * t + 0.15 * t * t;
      p.rotation += p.vr;

      if (y > canvas.height + 200) continue;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(p.rotation);

      // Draw mini card
      let w = 40, h = 56;
      ctx.fillStyle = '#fff';
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.roundRect(-w/2, -h/2, w, h, 4);
      ctx.fill();
      ctx.shadowBlur = 0;

      ctx.fillStyle = p.color === 'red' ? '#d32f2f' : '#222';
      ctx.font = 'bold 12px Segoe UI, Arial';
      ctx.textAlign = 'center';
      ctx.fillText(p.rank + p.suit, 0, -8);
      ctx.font = '18px serif';
      ctx.fillText(p.suit, 0, 14);
      ctx.restore();
    }

    let allDone = particles.every(p => {
      let age = now - p.born - p.delay;
      if (age < 0) return false;
      let t = age / 16;
      return p.y + p.vy * t + 0.15 * t * t > canvas.height + 200;
    });
    if (!allDone) cascadeAnimId = requestAnimationFrame(draw);
  }

  cascadeAnimId = requestAnimationFrame(draw);
}

function stopCascade() {
  if (cascadeAnimId) cancelAnimationFrame(cascadeAnimId);
  cascadeAnimId = null;
  let canvas = document.getElementById('cascade-canvas');
  let ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

// ========== Start ==========
updateScale();
newGame();
</script>
</body>
</html>
